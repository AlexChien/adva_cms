# Heavily inspired by Noel Rappin's "More Named Scope Awesomeness"
# http://www.pathf.com/blogs/2008/06/more-named-scope-awesomeness/

module ActiveRecord
  module HasFilter
    class << self
      def included(base)
        base.send :extend, ActMacro

        base.class_eval do
          scopes = { # FIXME make this writable
            :contains            => ["LIKE", "%", "%"],
            :does_not_contain    => ["NOT LIKE", "%", "%"],
            :starts_with         => ["LIKE", "", "%"],
            :does_not_start_with => ["NOT LIKE", "", "%"],
            :is                  => ["=", "", ""],
            :is_not              => ["<>", "", ""] }
            # created_before, created_after
            # updated_before, updated_after
            # author name, email

          scopes.each do |key, value|
            operator, prefix, suffix = value
            named_scope key, lambda { |column, string|
              query  = "lower(#{column}) #{operator} ?"
              string = "#{prefix}#{string.downcase}#{suffix}"
              { :conditions => [query, string] } 
            }
          end

          named_scope :scoped, lambda { |scope| scope }
        end
      end
    end

    module ActMacro
      def has_filter(*args)
        return if has_filter?
        include InstanceMethods
        extend ClassMethods
        
        # make it so that the frontend filter bar can be autogenerated from
        # whatever was defined here. maybe reflect on the attribute column types
        # and map certain possible filter types to them (like strings can be
        # filtered by is, is_not, ...) also add filter types based on model
        # properties like has_author, acts_as_taggable etc. and explicitely 
        # add options e.g. for assets (is_media_type)
        
        options = args.extract_options!
        class_inheritable_accessor  :filterable_attributes
        write_inheritable_attribute :filterable_attributes, args
      end
    
      def has_filter?
        included_modules.include? ActiveRecord::HasFilter::InstanceMethods
      end
    end
  
    module ClassMethods
      # Person.filter_by(first_name, :starts_with, "john")
      # Person.filter_by([:first_name, :starts_with, "john"], [:last_name, "contains", "doh"])
      def filter_by(*criteria)
        if criteria.first.is_a?(Array)
          criteria.inject(scoped({})) do |scope, criterion|
            scope.scoped(filter_by(*criterion).proxy_options)
          end
        else
          # FIXME opt in to and check filterable_attributes
          send(criteria.shift, *criteria)
        end
      end
    end

    module InstanceMethods
    end
  end
end

ActiveRecord::Base.send :include, ActiveRecord::HasFilter
